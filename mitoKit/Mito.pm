#!/usr/bin/env perl
##Pileup Format Parser
##By: Jingyu Lou @ Bio-X, SJTU
##Version: 0.3
##0.3: 2018-07-18 rewrite into a pm file
##0.2: 2016-12-07 merge lines which pos more than 16569

package Mito;
use strict;
use warnings;
use Data::Dumper;
require Exporter;
our @ISA = 'Exporter';
our @EXPORT = qw(samtools_mpileup parse indel_norm homo_het annotate compare);
our $VERSION = "0.3";



###Read Parameters from <CONFIG> file
my $config_parameters;
open CONFIG, '<', "CONFIG";
while (<CONFIG>) {
    next if m/#/;
    next if m/^\s*$/;
    chomp;
    m/(\S+)\s*=\s*(\S+)/;
    $config_parameters->{$1} = $2;
}

my ($chrM_bed, $chrM_ref, $table_path, $min_depth, $hetero_threshold) =
	map {$config_parameters->{$_}} qw/chrM_bed chrM_ref table_path min_depth hetero_threshold/;
close CONFIG;

###Read Sample information


###Global variables
#my $position_detail;





##Drainage "samtools mpileup BAM" to a filehandle
sub samtools_mpileup {
	use IO::Compress::Gzip qw/gzip $GzipError/;					##Use Zlib library for TOO LARGE of pileup format
	my $bam_file = $_[0];
#	my $chrM_ref = "/home/jingyu/temp/rCRS_Dup.fa";
	open my $mpileup_in, "samtools view -L $chrM_bed $bam_file -O bam | samtools mpileup -d 50000 -a - --reference $chrM_ref |";
#	open my $mpileup_out, '>', \ my $mpileup;
	my $mpileup_z = new IO::Compress::Gzip \ my $mpileup_gzip
		or die "gzip failed: $GzipError\n";
	my $data;
#	while (<>){																##For Debug
	while (<$mpileup_in>){
		chomp;
		my @line = split;
		my ($chr, $pos, $ref, $depth, $base, $qual) = @line;
		if ($pos <= 16569){
			$data->{$pos} = \ @line;
		}
		elsif (exists $data->{$pos - 16569}){
			$data->{$pos - 16569}->[3] += $depth;
			$data->{$pos - 16569}->[4] .= $base;
			$data->{$pos - 16569}->[5] .= $qual;
		}
		else {
			$line[1] = $pos -16569;
			$data->{$pos - 16569} = \ @line;
		}
	}
	foreach my $pos (sort {$a <=> $b} keys %$data){
#		print $mpileup_out join("\t", @{$data->{$pos}}), "\n";
		$mpileup_z->print(join("\t", @{$data->{$pos}}), "\n");
	}
	close $mpileup_in;
#	close $mpileup_out;
	$mpileup_z->close();
	return $mpileup_gzip;
}


## Parse pileup format generated by "samtools mpileup", use a filehandle as input

sub parse {
	#	my $mpileup_fl;
#	if (-e $_[0]) {
#		print STDERR "Reading $_[0]\n";
#		open $mpileup_fl, '<', $_[0];
#	}
#	else {
#		open $mpileup_fl, '<', \ $_[0];
#	}
	use IO::Uncompress::Gunzip qw(gunzip $GunzipError);
	my $mpileup_uz = new IO::Uncompress::Gunzip \ $_[0]
		or die "parse function failed: $GunzipError\n";

	open my $raw_parse_fl, '>', \ my $raw_parse;
	print $raw_parse_fl "#Chr\tPos\tRef\tCounts\tA\tT\tG\tC\tIndels\n";
    while (<$mpileup_uz>) {
		my %Indels;
		my %Base_counts = map { $_, 0 }	qw/ A T G C /;
		my ($chr, $pos, $ref, $Counts, $bases) = (split)[0..4];
		$ref = uc $ref;
		$bases = uc $bases;
		my @dNTPs = qw/ A T G C /;
		next unless (defined $bases);

	##count indels##
		while($bases =~ /[-+](\d+)/) {
			$bases =~ /\Q$&\E[a-zA-Z]{$1}/;
			my $one_indel = $&;
			while ($bases =~ s/\Q$one_indel\E//) {
				$Indels{$one_indel}++;
			}
		}

##transfer dot and comma to ref base and ref_reverse base##
#	my $rev = $base_rev{$ref};
		$bases =~ s/\./$ref/g;
		$bases =~ s/\,/$ref/g;

	##count A T C G##
		$bases =~ s/[^ATCG]//g;
		foreach my $dNTP (split //, $bases) {
			$Base_counts{$dNTP}++;
		}
		print $raw_parse_fl "$chr\t$pos\t$ref\t$Counts\t$Base_counts{A}\t$Base_counts{T}\t$Base_counts{G}\t$Base_counts{C}\t";
		foreach (sort { $Indels{$b} <=> $Indels{$a} } keys %Indels) {
			print $raw_parse_fl $_, ": ", $Indels{$_}, "\t"
		}
		print $raw_parse_fl "\n";
    }
    close $raw_parse_fl;
    return $raw_parse;
}






#sub merge {
#    open my $raw_parse_fl, '<', \ $_[0];
#    open my $merged_fl, '>', \ my $merged;
#   chomp(my $file = shift @ARGV);   
#   open LINE, '<', $file;
#    my %content;                              #use %content to store fixed content
 #   while (<$raw_parse_fl>) {
#	next if /#/;
#	chomp;
#	my @line = split /\t/;
#	my $pos = $line[1];
#	if ($pos <= 16569){
#		$content{$pos} = \@line;
#	} elsif (exists $content{$pos - 16569}){
#		fix(\@line);
#	} else {
#		$line[1] -= 16569;
#		$content{$pos-16569} = \@line;
#	}
 #   }
#
 #   print $merged_fl "#Chr\tPos\tRef\tCounts\tA\tT\tG\tC\tIndels\n";
  #  for my $i (1..16569){
#	my $line = defined $content{$i} ? join "\t", @{$content{$i}} : "chrM\t$i\tN\t0\t0\t0\t0\t0";
#	print $merged_fl $line, "\n";
 #   }
  #  close $merged_fl;
   # return $merged;

    #sub fix {
	#	my $fake = shift @_;
	#	my $real_pos = ${$fake}[1] - 16569;
	#	my $real = $content{$real_pos};
	#	for my $i (3..7){                             #add fake depth to real
	#		${$real}[$i] += ${$fake}[$i];
	#	}
	#	my %indels;
	#	for my $i (8..$#{$real}){
	#		$$real[$i] =~ /(.+): (\d+)/;
	#		$indels{$1} = $2;
	#	}
	#	for my $i (8..$#{$fake}){
	#		$$fake[$i] =~ /(.+): (\d+)/;
	#		$indels{$1} += $2;
	#	}
	#	my @indels;
	#	for (sort { $indels{$a} <=> $indels{$b} } keys %indels){
	#		push @indels, "$_: $indels{$_}";
	#	}
	#	@{$real} = @{$real}[0..7], @indels;
	#}
#}


sub indel_norm {
	my $position_detail;
	my $parsed_in;
#	open $parsed_in, '<', \ $_[0];
	open $parsed_in, '<', $_[0];
	open my $normed_out, '>', \ my $normed;
	my $content;
	while ( <$parsed_in> ){
#		print;
		chomp;
		my $line = $_;
		next if m/^#/;
		my @line = split /\t/, $_;
		my $pos = $line[1];
		$content->{$pos}->{REF} = $line[2];
		$content->{$pos}->{Counts} = $line[3];
		@{$content->{$pos}}{ qw/ A T G C / } = @line[4..7];
		if ( defined $line[8] ) {
			while( $line =~ s/([-+])(\d+)([A-Za-z]+): (\d+)// ) {
				my ($indel, $drift, $base, $counts) = ( $1, $2, $3, $4 );
				my ($allele, $conversion);
				if ($indel eq '+') {																			#####INSERTION
					$conversion = $content->{$pos}->{REF} . "/" . $content->{$pos}->{REF}.$base;
#					$indel_pos = $pos;
					$allele = "$pos.$base";
					$content->{$pos}->{INDEL}->{$allele}->{allele} = $allele;			##restore alelle format for insertion
					$content->{$pos}->{INDEL}->{$allele}->{depth} = $counts * 2;
				}
				else {
					$conversion = $base . "-del";
#					$indel_pos = $pos + 1;
					if ($drift == 1) {
						$allele = ($pos + 1) . "d";
					}
					else {
						my $del_start = $pos + 1;
						my $del_end = $pos + $drift;
						$allele = "$del_start-${del_end}d";
					}
					my $del_start = $pos + 1;
					my $del_end = $del_start + $drift - 1;
					for ( $del_start..$del_end ) {
						unless ( $_ >=16570 ) {
							$content->{$_}->{DEL} += $counts;
						}
						else {
							$content->{$_-16569}->{DEL} += $counts;
						}
					}
					my $real_pos =
						$pos + 1 > 16569 ?
						$pos -16568 :
						$pos + 1;
					$content->{$real_pos}->{INDEL}->{$conversion} =
						{
						 allele => $allele,
						 depth => $counts,
						};
				}
			}
		}
	}
	close $parsed_in;
#	if ( $debug ) {
#		print Dumper $content,"\n";
#		exit;
#	}
	say $normed_out "#Chr\tPos\tRef\tCounts\tA\tT\tG\tC\tDel";

	foreach my $pos ( sort { $a <=> $b } keys %$content ) {
		my $position = $content->{$pos};
		$position->{DEL} = $position->{DEL} // 0;
#		print Dumper $position;
		foreach ( qw/ A T G C DEL / ) {
			$position->{depth} += $position->{$_};
		}
#	my $diff = $position->{depth} - $position->{Counts};
		say $normed_out "chrM\t$pos\t$position->{REF}\t$position->{depth}\t$position->{A}\t$position->{T}\t$position->{G}\t$position->{C}\t$position->{DEL}";
		foreach (qw/A T G C DEL depth/) {
			$position_detail->{$pos}->{$_} = $position->{$_};
		}
		$position_detail->{$pos}->{bases_counts} = join "/", (map {$position_detail->{$pos}->{$_}} qw/A T G C DEL/);
		$position_detail->{$pos}->{bases_proportion} = join("/", (
																  map({sprintf "%.2g",
																	   ($position_detail->{$pos}->{depth}) ?
																	   $position_detail->{$pos}->{$_} / $position_detail->{$pos}->{depth} :
																	   0
																	  } qw/A T G C DEL/
																	 ),
																 )
														   );



#	say "$_\t$diff\t$position->{DEL}" if $diff;
	}

	say $normed_out "#Chr\tPos\tAllele\tInDels\tDepth";
	foreach my $pos ( sort { $a <=> $b } keys %$content ) {
		my $position = $content->{$pos};
		if ( defined $position->{INDEL} ) {
#		my $in_depth = 0;
#		foreach ( keys %{$position->{IN}->{1}} ) {
#			$in_depth += $position->{IN}->{1}->{$_};
#		}
#		say "chrM\t$\t$in_depth";
			my $INDEL_ref = $position->{INDEL};
			foreach my $conversion (sort {$INDEL_ref->{$b}->{depth} <=> $INDEL_ref->{$a}->{depth}} keys %$INDEL_ref){
				say $normed_out "chrM\t$pos\t", "$position->{INDEL}->{$conversion}->{allele}\t", "$conversion\t", "$position->{INDEL}->{$conversion}->{depth}";
			}
		}
	}
#	print Dumper $content;
#	print Dumper $position_detail and exit;
	return ($normed, $content, $position_detail);
	## sub
	sub _geno_format {
		my $bin_geno = sprintf "%b", ( shift @_ );
		my $format;
		next if $bin_geno == 0;
		while ( $bin_geno =~ s/[01]{1,5}$// ) {
			$format = defined $format ?
				$& . ',' . $format :
				$&;
		}
		return $format;
	}
}





#sub get_file {
#	my $file = shift @_;
#	open my $file_in, '<', $file;
#	open my $file_out, '>', \ my $file_content;
#	while (<$file_in>){
#		print $file_out $_;
#	}
#	return $file_content;
#}




###precess parsed data into homoplasy or heteroplasmy mutations
sub homo_het {
	my $content = $_[1];
	my $position_detail = $_[2];
	open my $homo_het_fl, '>', \ my $homo_het_out;
	print $homo_het_fl join "\t", "#Pos\tRef\tDepth\tConversion\tHomo/Het\tHet_Ratio\n";
	foreach my $pos (sort {$a <=> $b} keys %$content) {
		my @indel = keys %{$content->{$pos}->{INDEL}};
		my @allele = (map({$pos . $_} qw/ A T G C/),
						map({$content->{$pos}->{INDEL}->{$_}->{allele}} @indel));
		my @mutation = (qw/A T G C/, @indel);
		my @conversion = map {$content->{$pos}->{REF} . $pos . $_} qw/ A T G C /;
		@conversion = (@conversion, @indel);
		my %mutation_reference = map {$conversion[$_] => $mutation[$_]} (0..$#mutation);
		my %allele_reference = map {$conversion[$_] => $allele[$_]} (0..$#allele);
		my @every_depth = map {$content->{$pos}->{$_}} qw/ A T G C/;
		@every_depth = (@every_depth, map {$content->{$pos}->{INDEL}->{$_}->{depth}} @indel);
		@conversion = @conversion[sort {$every_depth[$b] <=> $every_depth[$a]} (0..$#every_depth)];
		my @sorted_depth = sort {$b <=> $a} @every_depth;


		if ($mutation_reference{$conversion[0]} ne $content->{$pos}->{REF}) {
			print $homo_het_fl join "\t",
				"$pos", $content->{$pos}->{REF}, $content->{$pos}->{depth}, $allele_reference{$conversion[0]}, "Homo", "NA";
			print $homo_het_fl "\n";
		}
		my $het_ratio = ($content->{$pos}->{depth} == 0) ? 0 : $sorted_depth[1] / $content->{$pos}->{depth};
		if ($het_ratio >= $hetero_threshold
			and $mutation_reference{$conversion[1]} ne $content->{$pos}->{REF}
			and	$sorted_depth[1] > 1)
			{
				print $homo_het_fl join "\t",
					"$pos", $content->{$pos}->{REF}, $content->{$pos}->{depth}, $allele_reference{$conversion[1]}, "Het", $het_ratio;
				print $homo_het_fl "\n";
			}
	}
	return ($homo_het_out, $position_detail);
}


##Annotate reported loci associated with disease
sub annotate {
	my $position_detail = $_[1];
	open my $database_in, '<', $table_path;
	open my $homo_het_in, '<', \ $_[0];
	open my $annotation_fl, '>', \ my $annotation_out;
	my $database_form;
	my $note;
	my $database_header = <$database_in>;
	chomp $database_header;
	my @database_column = split "\t", $database_header;
	while (<$database_in>) {
		chomp;
		my @line = split "\t", $_;
		my $pos = $1 if $line[1] =~ m/^(\d+)/;
		my $conversion = $line[0];
		my $index = 0;
		foreach my $col (@database_column) {
			$database_form->{$conversion}->{$col} = $line[$index];
			$index++;
		}
		$position_detail->{$pos}->{locus} = $line[2];
	}
	close $database_in;
#	print Dumper $database_form;
	###
#		$data_set->{$pos_db} =
#			{
#			 $conversion_db => {
#								LOCUS => $locus_db,
#								AACHANGE => $aachange_db,
#								HOMO => $homo_db,
#								HET => $het_db,
#								STATUS => $status_db,
#							   },
#			};
#	print Dumper $data_set;
#	print join("\t", "#Pos", "Locus", "Ref", "Conversion", "Homoplasmy", "Heteroplasy", "Hetero"), "\n";

#	@database_column = (@database_column[0..2], @database_column[3..$#database_column]); ##Merge bases proportion to final layout
	my @output_column = (3..$#database_column);
	while (<$homo_het_in>) {
		if (/#/) {
			print $annotation_fl join("\t", "#Pos", "Ref", "Conversion", "Locus", "Homo_Or_Het", "Depth", "Child_Bases_Counts(A/T/G/C/Del)", "Child_Bases_Proportion(A/T/G/C/Del)", @database_column[@output_column]), "\n";
			next;
		}
		chomp;
		my @line = split "\t", $_;
		my ($pos, $ref, $depth, $conversion, $homo_het, $het_MAF) = @line;
#		my $bases_counts = join "/", (map {$position_detail->{$pos}->{$_}} qw/A T G C DEL/);
#		my $bases_counts = $position_detail->{$pos}->{bases_counts};
#		my $bases_proportion = join("/", (
#										  map({sprintf "%.2g",
#											   ($position_detail->{$pos}->{depth}) ?
#											   $position_detail->{$pos}->{$_} / $position_detail->{$pos}->{depth} :
#											   0
#											  } qw/A T G C DEL/
#											 ),
#										 )
#								   );
#		my $bases_proportion = $position_detail->{$pos}->{bases_proportion};
		my $priority = 0;
#		@line = (@line[0..2], $bases_counts, $bases_proportion, @line[3..$#line]);
		next if $depth < $min_depth;
		my $isHomo = ($homo_het =~ m/\QHomo\E/) ? "Y" : "N";
		my $isHet = ($homo_het =~ m/\QHet\E/) ? "Y" : "N";

		if (!exists $database_form->{$conversion}) {
			$database_form->{$conversion} = {$database_column[0] => $conversion,
											 $database_column[1] => $pos,
											 "Priority" => 0,
											 "Locus" => $position_detail->{$pos}->{locus},
											};
			foreach my $col (@database_column) {									##set all variables to NA if cannot find that conversion in database
				$database_form->{$conversion}->{$col} = "NA" unless defined $database_form->{$conversion}->{$col};
			}
		}
		if ($isHomo eq $database_form->{$conversion}->{Mitomap_Homoplasmy} and
			$isHomo eq "Y") {
			$priority++;
		}
		if ($isHet eq $database_form->{$conversion}->{Mitomap_Heteroplasmy} and
			$isHet eq "Y") {
			$priority++;
		}
		$database_form->{$conversion}->{Priority} += $priority;
		print $annotation_fl join("\t", $pos, $ref, $conversion,
								  $database_form->{$conversion}->{Locus},
								  $homo_het, $depth,
								  $position_detail->{$pos}->{bases_counts},
								  $position_detail->{$pos}->{bases_proportion},
								  map {$database_form->{$conversion}->{$_}} @database_column[@output_column]), "\n";
	};
	return ($annotation_out, $position_detail);
}

=DEPRECATED
		foreach my $conversion_db (%{$database_form->{$pos}}) {
			next unless $conversion_db eq $conversion;
			my $conversion_arrow = $database_form->{$pos}->{$conversion_db};
			$het_MAF = 0 unless $het =~ m/\+/;
			$priority++ if $homo eq $conversion_arrow->{HOMO};
			$priority++ if $het eq $conversion_arrow->{HET};
			$priority++ if $conversion_arrow->{STATUS} =~ m/Reported/;
			$priority += 2 if $conversion_arrow->{STATUS} =~ m/Cfrm/;
			print $annotation_fl join("\t",
									  $pos,
									  $database_form->{$pos}->{$conversion}->{LOCUS},
									  $ref,
									  $conversion,
									  $homo,
									  $het,
									  $het_MAF,
									  $priority,
									 ), "\n";
			}
	}
	return $annotation_out;
}
=cut


sub compare {
	my ($child_file, $mother_file, $child_position_detail, $mother_position_detail) = @_;
	open my $child_readin, '<', $child_file;
	open my $mother_readin, '<', $mother_file;
	open my $compare_out_fl, '>', \ my $compare_out;
#	print $mother_file, "\n" and exit;
	my $mother_dataset;
	my $header = <$mother_readin>;
	chomp $header;
	my @columns = split "\t", $header;
	my $priority_pos = 0;					##Ensure "de_novo" column was set before "priority" column
	my $homo_pos = 0;
	my $bases_proportion_pos = 0;
	while (!($columns[$priority_pos] =~ /Priority/)) {$priority_pos++;}
	while (!($columns[$bases_proportion_pos] =~ /Bases_Proportion/)) {$bases_proportion_pos++};
	while (!($columns[$homo_pos] =~ /Homo_Or_Het/)) {$homo_pos++;}
	while (<$mother_readin>) {
		chomp;
		my @line = split "\t", $_;
		my $conversion = $line[2];
		map {$mother_dataset->{$conversion}->{$columns[$_]} = $line[$_]} (0..$#line);
	}
	while (<$child_readin>) {
		chomp;
		my @line = split "\t", $_;
		my $pos = $line[0];
		if (/^#/) {
			print $compare_out_fl join("\t",
									   @columns[0..($bases_proportion_pos - 2)],
									   "Child_Bases_Counts",
									   "Child_Bases_Proportion",
									   "Mother_Bases_Counts",
									   "Mother_Bases_Proportion",
									   @columns[($bases_proportion_pos + 1)..($priority_pos - 1)],
									   "de_novo",
									   @columns[$priority_pos..$#columns]
									  ), "\n";
			next;
		}
		my $de_novo;
		my $conversion = $line[2];
		if (!exists $mother_dataset->{$conversion}) {
			$de_novo = "de novo";
			$line[$priority_pos] += 2;
		}
		elsif ($line[$homo_pos] ne $mother_dataset->{$conversion}->{Homo_Or_Het}) {
			$de_novo = "Somatic";
			$line[$priority_pos] += 1;
		}
		else {
			$de_novo = "N";
		}
		print $compare_out_fl join("\t",
								   @line[0..$bases_proportion_pos],
								   $mother_position_detail->{$pos}->{bases_counts},
								   $mother_position_detail->{$pos}->{bases_proportion},
								   @line[($bases_proportion_pos + 1)..($priority_pos - 1)],
								   $de_novo,
								   @line[$priority_pos..$#line]
								  ), "\n";
	}
	return $compare_out;
}



1;
